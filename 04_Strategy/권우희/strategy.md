# Strategy Pattern

> **한줄요약**
>
> 알고리즘(전략)을 객체로 분리해, 같은 문제를 다양한 방식으로 해결할 수 있도록 유연성을 높여주는 디자인 패턴

---

## 정의

알고리즘과 각각 클래스를 분리하고,
필요한 시점에 객체에게 알고리즘(전략)을 **주입**해서 유연하게 알고리즘을 바꿀 수 있게 하는 것.

---

## 전략패턴이 필요한 상황

- 게임에서 캐릭터가 무기/스킬을 바꾸는 경우
- 결제 방식 선택 (카드, 간편결제, 무통장 등)

---

## 다형성과 전략패턴의 차이

- 다형성을 활용한 예제 코드
  - 객체를 생성해야 행동이 바뀜

```java
Animal a = new Dog();
a.sound();
a = new Cat();  //다른 알고리즘을 사용하기 위해 새로운 객체 생성
a.sound();
```

- strategy 패턴을 활용한 예제 코드
  - 별도의 객체를 생성하지 않고 주입을 통해 행동을 변경할 수 있음.

```java
Animal a = new Animal(new DogSound());
a.sound();
//메서드를 통해 새로운 객체를 생성하지 않고, 매개변수를 이용하여 알고리즘을 변경
a.setSoundStrategy(new CatSound());
a.sound();
```

### 결론

다형성은 새로운 알고리즘을 취할때마다 객체를 새로 생성해야하지만 전략 패턴을 사용할 경우 같은 인스턴스에 주입만 바꿔주면 된다.

- 공통 부분을 추가할 때, 다형성을 이용한다면 모든 클래스에 추가해줘야한다.

---

## strategy pattern의 구성요소

### Strategy

- 알고리즘을 이용하기 위한 인터페이스

### concreteStrategy

- 구체적인 전략을 실제로 프로그래밍하는 구현체

### Context

- ConcreateStrategy의 인스턴스를 가지고 있다가 필요에 의해 이용한다.
- 호출하는 것은 strategy의 인터페이스다.

---

## 장점

- 위임이라는 약한 결합을 사용하여 알고리즘을 용이하게 전환할 수 있다.
- 실행 중에도 알고리즘 교체가 가능하다.

## 단점

- 만일 어플리케이션 특성이 알고리즘이 많지 않고 자주 변경되지 않는다면
  새로운 클래스와 인터페이스를 만들어 프로그램을 복잡하게 만들 이유가 없다.
