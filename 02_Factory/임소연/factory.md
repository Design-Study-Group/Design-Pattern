# Factory Method (팩토리 메서드)

객체를 직접 만들지 않고(new 연산자 사용),  
**서브 클래스(자식 클래스)가 어떤 클래스를 만들지 결정**하도록 하는 방식

## 사용 상황

- new로 직접 객체를 만들기엔 너무 복잡하거나 다양할 때
  → 예: 햄버거 주문 시 종류가 너무 많아져서 if문이 길어질 때

- 어떤 객체를 만들지는 상황(환경, 설정 등)에 따라 달라질 때
  → 예: 웹에서 결제 요청이 왔을 때 카카오페이, 토스, 네이버페이 중 하나를 선택해서 생성

- 클래스를 바꾸지 않고 객체 생성 방식을 바꾸고 싶을 때
  → 자바 OOP의 원칙 "확장에는 열려 있고, 수정에는 닫혀 있어야 한다"를 지키고 싶을 때

## 구조

``` java
[Creator (abstract)] — 객체 생성을 위한 추상 메서드 포함
        ▲
        │extends
[ConcreteCreator] — 실제 객체 생성 방식 구현   ◀︎⎯⎯⎯⎯⎯⎯
                                                    │
[Product (interface)] — 공통 기능 정의               create
        ▲                                           │
        │extends                                    │
[ConcreteProduct] — 실제 객체들 (예: CheeseBurger, BulgogiBurger)
```

- Product: 만들고 싶은 객체의 공통 타입(인터페이스/부모 클래스)
- ConcreteProduct: 실제로 만들어지는 다양한 객체(자식 클래스)
- Creator: 객체를 만들어주는 팩토리 메서드를 가진 클래스(보통 추상 클래스)
- ConcreteCreator: 팩토리 메서드를 실제로 구현해서 원하는 객체를 만드는 클래스

## 구현 방법 (Java 기준)

- Product 인터페이스/추상 클래스 정의
  (예: Payment)

- 여러 ConcreteProduct 클래스 구현
  (예: CardPayment, KakaoPayment, NaverPayment)

- Creator 추상 클래스 정의,
  여기서 팩토리 메서드(예: createProduct())를 추상 메서드로 선언

- ConcreteCreator 클래스에서 팩토리 메서드를 오버라이드하여
  실제로 어떤 객체를 만들지 결정

### 참고

- 코드의 결합도를 낮출 수 있음
  (새로운 종류가 추가될 때 기존 코드를 거의 건드리지 않아도 됨)

- 확장성에 유리
  (새로운 제품이 생겨도 팩토리만 추가하면 됨)

- 클래스가 많아질 수 있음(단점)
  (제품이 늘어날 때마다 팩토리도 늘어날 수 있음)

- Simple Factory랑 비슷하지만  
  → 팩토리 메서드는 상속을 활용해서 확장성을 더 중요시

- 스프링 프레임워크의 BeanFactory, ApplicationContext도 이 패턴을 사용

유사한 패턴들 비교

| 패턴          | 피자 예시 설명 요약                                          |
| ------------- | ------------------------------------------------------------ |
| 빌더          | 넣는 재료(옵션)에 따라 다양한 피자를 만드는 과정             |
| 템플릿 메서드 | 만드는 순서는 같고, 각 단계(도우, 소스 등)만 다르게 구현     |
| 심플 팩토리   | 주문에 따라 분기문으로 다른 피자 객체를 생성                 |
| 팩토리 메서드 | 피자 가게(서브클래스)마다 어떤 피자를 만들지 다형성으로 분리 |
