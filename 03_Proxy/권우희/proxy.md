# Proxy Pattern

> **한줄요약**
> 
> 우선적으로 처리할 수 있는 것은 처리한 후 실제동작은 그 기능이 진짜 필요할 때 불러온다.

## Proxy란?
- 사전적의미로는 "대리인"이라고 한다.
- 본인이 아니어도 할 수 있는 일을 맡기고자 대리인을 내세운다.

## Proxy 패턴을 사용하는 이유?
- 이미지나 영상처럼 무겁고 느린 리소스를 늦게 로딩하고 싶을 때
- 보안, 접근 제한이 필요할 때
- 로그 남기기, 캐시 같은 기능을 추가하고 싶을 때
- 실제 객체가 다른 서버에 있는 경우 (원격 프록시)
- 핵심은 대리인이 할 수 있는 범위까지만 보여주고, 그 범위가 넘어서면 원본에게 책임을 넘긴다.

## 예시
- 썸네일 등

| 사용처     | Proxy가 하는 일   | Real 객체   |
|---------|---------------|-----------|
| API 캐시  | 응답 저장/재사용     | 외부 API 서버 |
| 인증 검사   | 로그인/권한 확인     | 진짜 컨트롤러   |
| 지연 로딩   | 가짜 썸네일, 로딩 UI | 실제 데이터    |
| 리버스 프록시 | 보안, 트래픽 분산    | 백엔드 서버    |
| 로깅/모니터링 | 로그 수집         | 비즈니스 로직   |


## 구성요소
### subject
- 인터페이스 역할.
- 예시에서는 `Printable`클래스가 해당 역할을 함.

### proxy
- client의 역할을 우선 처리한다.
- 하지만 혼자 처리할 수 없다면 proxy는 RealSubject에게 처리를 맡긴다.
- 예시에서는 `PrinterProxy` 클래스가 해당 역할을 함.

### realSubject
- Proxy 만으로 감당할 수 없을 때 사용된다.
- Subject에서 정의한 인터페이스(API)를 구현한다.
- 예시에서는 `printer`클래스가 해당 역할을 함.

### client
- Proxy패턴을 이용
- 예시에서는 `Main`클래스가 해당 역할을 함.

## Proxy 종류
### 가상 프록시 (Virtual Proxy)
- 지연 초기화 방식
- 가끔 필요하지만 항상 메모리에 적재되어있는 무거운 서비스 객체가 있는 경우
- 객체 생성에 많은 자원이 소모되지만, 사용빈도는 낮을 때 쓰는 방식이다.
- 서비스가 시작될때, 객체를 생성하는 대신 객체 초기가 실제로 필요한 시점에 초기화될 수 있도록 지연할 수 있다.

### 원격 프록시 (Remote Proxy)
- RealSubject가 네트워크 저편에 있음에도 불구하고 마치 자기 옆에 있는 것 처럼 메서드를 호출할 수 있다.


### 보호 프록시 (Access Proxy)
- 접근제한을 설정한다.